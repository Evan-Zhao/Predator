\label{sec:futurework}

\subsection{Approach Applicability}
The approach of combining compiler instrumentation and runtime system does not rely on the support of specific hardware, OS and libraries.
Hence, it is applicable to detect and predict false sharing in different levels of 
software stack in theory, including hypervisors, operating systems, libraries or 
applications using different threading libraries.
However, some components of \Predator{} has to be 
modified correspondingly.
For example, \Predator{} has to identify computing unit of all memory accesses, e.g., different virtual machines, tasks or threads. 
Different system has their own specific allocation and deallocations, which should be intercepted appropriately. Extending \Predator{} to different levels of software stack will be the future work for us.


\subsection{Performance Improvement}
\Predator{} runs around $6\times$ slower on average for all evaluated applications. 
In our current implementation, every memory access is instrumented with a library call 
in order to notify the runtime system for tracking purpose. A library call entails not only normal function call overhead but also Global Offset Table(GOT) and/or Procedure Linkage Table (PLT) look-up overhead. 
It is too heavy for simple computations, listed in the following:

\begin{itemize}
\item
Before the number of writes on a cache line reaches {\it Tracking-Threshold},  \Predator{} simply increments its write counter.

\item
In the sampling mechanism discussed in Section~\ref{sec:sample}, most accesses (99\%) outside sampling period only needs to increment access counters of cache lines.
\end{itemize}

These computations only involve in simple checking or updating operations, normally taking only a few CPU cycles to finish. 
In the future, we plan to further improve the performance of \Predator{} by instrumenting those simple computations directly, instead of using library calls to notify runtime system.

\subsection{Valuable Suggestions}
\Predator{} can be extended to provide suggestions for fixing false sharing problems based on the memory trace information, which can help reduce the manual overhead of fixing false sharing problems.  
