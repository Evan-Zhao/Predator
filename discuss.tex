\label{sec:discussion}

\subsection{Limitation on Prediction}
As discussed in Section~\ref{sec:intro}, many dynamic properties
can affect occurrences of false sharing. 
\Predator{} can predict potential false sharing caused by cache line size 
or an object's starting address change for the same binary.
However, it can not predict false sharing in the case of  
memory layout change made by different compiler. 
For example,  two global variables $A$ and $B$, which do not fit into 
the same cache line when compiled using $llvm$, may be placed close to each
other by another compiler, and thus lead to false sharing. 
\Predator {} does not consider such kind of false sharing, because
it is impossible to predict the behavior of different compilers.

\subsection{Application to Kernel and Hypervisor}
\begin{comment}
Although \Predator{} conceptually can be used to detect false sharing in different levels of 
software stack, currently it can not be applied to those levels directly. 
Some components, like customized memory manager, can only work in user level. Also, \Predator{}
has to identify the source of accesses using some system specfic calls. For example, it uses
gettid() to identify accesses from different threads.   
Extending \Predator{} to different levels of software stack will be the future work for us.
\end{comment}

\subsection{Performance Improvement}
\Predator{} runs around $6.6$X slower on average for all evaluated benchmarks. 
In our current implementation, all memory accesses are instrumented with a library call to 
invoke the runtime system for tracking. 
This long jump from user code to library call entails large performance overhead
since it needs to go through Global Offset Table (GOT) and Procedure Linkage Table (PLT).
However, certain logic implemented in library are as simple as reading or
incrementing counters. Two identifed places are shown below:

\begin{itemize}
\item
Upon an access to a cache line, 
\Predator{} simply incrementes this line's write counter for write and
ignore read until the counter value reaches {\it Tracking-Threshold}. 
\item
In sampling mechanism discussed in Section~\ref{sec:sample}, 
most accesses (99\%) only needs to increment access counters of cache lines.
\end{itemize}

Implementing such logic only needs a few low latency instructions instead of expensive
library calls. In the future, \Predator{} should 
selectively expand library calls so that for simple logic, instructions are inserted 
directly into user code. This will certainly improve the performance.

