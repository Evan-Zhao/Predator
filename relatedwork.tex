\label{sec:relatedwork}

This section describes related work in false sharing detection, prevention, or both. There is no previous
system to predict unobserved false sharing.

\subsection{False Sharing Detection}
Based on the SIMICS functional simulator, Schindewolf et al.\ designed a tool to report different kinds of cache usage information, such as cache misses and cache invalidations~\cite{falseshare:simulator}. Pluto relies on Valgrind dynamic instrumentation framework to track the sequence of memory read and write events on different threads, and reports a worst-case estimation of possible false sharing~\cite{falseshare:binaryinstrumentation1}.
Similarly, Liu uses Pin to collect memory access information, and reports total cache miss information~\cite{falseshare:binaryinstrumentation2}.
These tools impose about $100-200\times$ performance overhead.

Zhao et al.\ developed a tool based on DynamoRIO framework to detect false sharing and other cache contention problems
for multithreading programs~\cite{qinzhaodetection}. 
It uses a shadow memory technique to maintain memory access history and detects cache invalidations based on the ownership of cache lines. However, it can only support at most $8$ threads. In addition, it cannot differentiate cold cache misses from actual false sharing problems.

Intel's performance tuning utility (PTU)~\cite{detect:ptu, detect:intel} uses Precise Event Based Sampling (PEBS) hardware support to detect false sharing problems.  It can only point out those functions that might cause false sharing, but no line number information on a false sharing problem.  PTU cannot distinguish true sharing from false sharing. In addition, PTU aggregates memory accesses without considering the memory re-usage and access interleaving, leading to numerous false positives. Sanath et.al. designed a machine learning based approach to detect false sharing problems. They train their classifier on mini-programs and apply this classifier to general programs ~\cite{mldetect}. In stead of instrument memory accesses, this tool relies on hardware performance counters to collect memory accesses events. So it achieves very low performance overhead, about 2\% performance overhead. But it relies on hardware support for its efficiency.  

In addition to their individual disadvantages,
all approaches discussed above share a common shortcoming:  
they cannot pinpoint the exact location of false sharing in the source code, so programmers have to examine the source code and identify problems manually.

Pesterev et.al.\ presents DProf, a tool that help programmers identify cache misses based on AMD's instruction-based sampling hardware~\cite{DProf}. DProf requires manual annotation to locate data types and object fields, and cannot detect false sharing when multiple objects reside on the same cache line.

\subsection{False Sharing Prevention}
Jeremiassen and Eggers use a compiler transformation to automatically adjust the memory layout of applications through padding and alignment~\cite{falseshare:compile}. Chow et al.\ alter parallel loop scheduling in order to avoid false
sharing~\cite{falseshare:schedule}. These approaches only works for regular, array-based scientific code.

Berger et al.\ describe Hoard, a scalable memory allocator that can reduce the possibility of false sharing by making different threads use different heaps~\cite{Hoard}. Hoard cannot avoid false sharing problem in global variables or within
a single heap object: the latter appears to be the primary source of real false sharing problems.

\subsection{False Sharing Detection and Prevention}
\sheriff{}~\cite{sheriff} provides two tools to handle false sharing based on their ``threads-as-processes'' framework.
\Sheriff{}'s detection tool report false sharing accurately and precisely with only $20\%$ performance overhead.
However, it can only detect write-write type of false sharing for those programs using \pthreads{} library. It can also break correctness for those programs communicating across different threads with stack variables or ad hoc synchronizations (e.g. self-defined variables). These shortcomings greatly limit their usage on real-world applications.  
\Predator{} can detect all kinds of false sharing and has no limitations on applications. \Predator{} has been utilized to find actual false sharing in real applications like \texttt{MySQL} and the \texttt{Boost} library.

\Sheriff{}'s prevention tool prevents false sharing from happening. Unfortunately, it only improves performance for programs with a small amount of synchronizations. 
For those programs with a large number of synchronizations, the overhead imposing by \Sheriff{} could lead to performance degradation.
%Both \SheriffDetect{} and \SheriffProtect{} assumes the correct usage of \pthreads{} APIs,  
%so they may not work correctly for those programs having ad-hoc
%synchronizations (e.g., flag synchronizations) or using stack variables to communicate among threads.

Plastic~\cite{OSdetection} leverages the sub-page granularity memory remapping facility provided by Xen hypervisor to detect and tolerate false sharing automatically. However, the sub-page memory remapping mechanism is not supported by most existing operating system currently, reducing its universality. In addition, Plastic cannot pinpoint the exact source of false sharing.  
In order to utilize their prevention tool, a program has to run on the Xen hypervisor, limiting the applicability of their prevention technique.
