\label{sec:relatedwork}

Since none of existing approaches can predict potential false sharing without occurrences, 
we only talk about those related work in false sharing detection or prevention or both in the following.

\subsection{False Sharing Detection}
Based on the SIMICS functional simulator, Schindewolf et al. designed a tool 
to report different kinds of cache usage information,
such as cache miss and cache invalidations~\cite{falseshare:simulator}.
Pluto utilizes Valgrind to track the sequence of memory read and write
events on different threads and reports a worst-case estimation of
possible false sharing~\cite{falseshare:binaryinstrumentation1}.
Similarly, Liu uses Pin to collect memory access information and
reports total false sharing caused miss information~\cite{falseshare:binaryinstrumentation2}.
These tools can only report the possibility of false sharing without precise information of each
actual false sharing problem.  
Also, they impose about 100x-200x performance overhead on executions.  

Zhao et al.\ developed a dynamic instrumentation based approach to 
detect false sharing and other cache contention problems
for multithreading programs~\cite{qinzhaodetection}. 
%This tool instruments those memory references dynamically using Umbra~\cite{Umbra}, 
%in order to track the ownership of cache lines. 
It uses shadow memory technique to maintain memory access history and track the ownership of 
cache lines. 
However, it can only support at most $8$ threads and its memory overhead 
is above $2\times$. Besides, they can not differentiate cold cache misses with 
actual false sharing problems due to their instrumentation limitation. 

Intel's performance tuning utility (PTU)~\cite{detect:ptu, detect:intel} uses Precise
Event Based Sampling (PEBS) hardware support to detect false sharing problems. 
It can only point out those functions that might cause false sharings.
Also, PTU cannot differentiate true sharing from
false sharing. Besides, PTU aggregates memory accesses without considering the memory re-usage and
access interleaving, thus it reports a lot of
false sharing problems without actual performance impact.

In addition to their individual disadvantages,
all above approaches share a common shortcoming. 
They cannot pinpoint the exact location of false sharing in the source code, 
so programmers have to examine the source code and identify problems manually.

Pesterev et al.\ develop a tool, DProf, to help programmers identify cache misses based on
AMD's instruction-based sampling hardware~\cite{DProf}.
DProf requires manual annotation to locate data types and object fields, and cannot detect false
sharing when multiple objects reside on the same cache line.

\subsection{False Sharing Prevention}
Jeremiassen and Eggers use a compiler transformation to automatically adjust the
memory layout of applications through padding and alignment~\cite{falseshare:compile}.
Chow et al.\ describe an approach to alter parallel loop scheduling to avoid
sharing~\cite{falseshare:schedule}.
These static analysis based approaches only works for regular,
array-based scientific codes.

Berger et al.\ describes Hoard, a scalable memory allocator that can reduce
the possibility of false sharing
by making different threads use different heaps~\cite{Hoard}.
The drawback of Hoard is that it can not avoid false sharing problems of global variables 
and a single heap object.
Actually, most of found significant false sharing problems are coming from a single heap object. 

\subsection{False Sharing Detection and Prevention}
\sheriff{}~\cite{sheriff} provides two tools to handle false sharing based on 
their ``threads-as-processes'' framework that turns threads to processes for applications using 
\pthreads{} libraries.
\Sheriff{}'s detection tool 
can report false sharing accurately and precisely with only $20\%$ performance overhead.
However, it can only detect write-write type of false sharing for those programs 
using \pthreads{} library and it can break correctness for those programs using 
stack variables or ad hoc synchronizations (e.g. self-defined variables)
to communication across different threads.
These shortcomings greatly limit their usage on real-world applications.  
On the contrary, our work can detect all kinds of false sharing and has no limitations on applications.
\Predator{} has been utilized to find actual false sharing in \texttt{MySQL} server applications 
and \texttt{boost} libraries.

\Sheriff{}'s prevention tool prevents false sharing from happening. 
Unfortunately, it only improves performance for programs having small amount of synchronizations. 
For those programs with very significant 
amount of synchronizations, it might slow down the execution instead.
%Both \SheriffDetect{} and \SheriffProtect{} assumes the correct usage of \pthreads{} APIs,  
%so they may not work correctly for those programs having ad-hoc
%synchronizations (e.g., flag synchronizations) or using stack variables to communicate among threads.

Plastic~\cite{OSdetection} leverages the {\it sub-page granularity memory remapping facility}
provided by Xen hypervisor to detect and tolerate false sharing automatically.
However, the sub-page memory remapping mechanism is not supported by most existing operating 
system currently, making it a non-universal solution. Moreover, like other
detection tools, Plastic cannot locate the exact source of false sharing.  
In order to utilize their prevention, the programs has to run on Xen hypervisor, 
which make it not appealing any more.
