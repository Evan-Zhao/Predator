%False sharing problem is a cache usage problem. 
%Cache, with much faster access speed than main memory, is normally utilized by CPU
%to accelerate program executions by preloading a fixed size of data into the cache each time, 
%called as a cache line.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Why 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:intro} 

Parallelism is a general approach to fully utilize multi-core resources in the modern architecture. 
However, it is hard to achieve high performance and linear scalability because of shared 
resource contention among different computing units, e.g. processes, tasks, threads.
False sharing is an example of resource contention: false sharing occurs when 
different computing units running on different cores with their own private caches 
simultaneously access independent data residing on the same cache line.
False sharing, because of cache coherence protocol, can severely degrade software 
performance, as much as an order of magnitude~\cite{falseshareeffect}.
Originally cache coherence protocol is used to ensure correctness of program executions: 
if some data in a cache line (e.g. $64$ bytes) on one core has been updated, 
duplicates of this cache line in aother core's private 
cache must be invalidated. 
In false sharing case, those cache invalidations are totally unnecessary and only
cause performance issue. 
When a cache line is marked as invalid, 
later accesses must retrieve an up-to-date copy of the whole cache line 
from main memory or another core's cache.
This wastes both the CPU time and memory bandwidth in the same time. 
Unfortunately, hardware trend of building more cores
or with larger cache line size makes false sharing increasingly common.

False sharing has been found in different levels of software stack, including
OS (Linux kernel~\cite{OSfalsesharing}), Java virtual machine~\cite{JVMfalsesharing}, 
common libraries~\cite{libfalsesharing} and real applications~\cite{appfalsesharing, mysql}. 
People also observed false sharing in share memory system
~\cite{dsmfalsesharing} and transactional memory ~\cite{tmfalsesharing}.
Although many efforts have been made in false sharing detection, existing
tools have various limitations:
they either introduce significant performance overhead~
\cite{falseshare:simulator, falseshare:binaryinstrumentation1,falseshare:binaryinstrumentation2}, or 
are incapable of reporting false sharing 
precisely and accurately~\cite{qinzhaodetection, detect:ptu, detect:intel, falseshare:binaryinstrumentation1, DProf, falseshare:binaryinstrumentation2}, 
or require special OS support~\cite{OSdetection}.
% or they can only detect one kind of
%false sharing problem on a specific multithreading library~\cite{sheriff}.
Sheriff~\cite{sheriff} does not have these shortcomings but has its own limitations: 
it can only detect write-write type false sharing in programs using pthreads library,
and can break correctness of programs using ad-hoc synchronizations or using stack variables to 
communicate across different threads. 
%Also, none of these existing approaches  has been verified to find actual 
%false sharing problems in real applications.

Despite their different features and limitations, all existing detection tools 
share two more common drawbacks.
Firstly, existing techniques can not be applied for 
the entire software stack.
% although they might work on a specific level of software stack.
Secondly, existing tools can only detect those false sharing occurring in current execution.
However, as pointed out by Nanavati et al.~\cite{OSdetection}, 
many dynamic properties can easily change manifestness of false sharing problems.
They also give an example that 
{\it "GCC fixes false sharing in the Phoenix linear\_regression benchmark 
at -O2 and -O3 optimization, while clang fails to even at the highest
optimization level".}
To our understanding, dynamic properties include 
choosing different compiler, 
enabling different compiler optimizations, 
using different memory management schemes,
and changing different target platforms such as address mode (32-bit or 64-bit) and cache line
size (64 Bytes or 128 Bytes) and so on. 
Existing detection tools do not take into account these dynamic properties, and
therefore are unable to identify potential performance-degrading false
sharing problems that may occur in an execution under a different set of 
dynamic properties.

In this paper, we propose a new false sharing detector, \Predator{}.
It aims to not only {\it detect} all existing false sharing problems accurately and precisely,
but {\it predict} those potential 
false sharing problems that may appear in a slightly different environment. 
%To be more specific, 
%\Predator{} can report potential false sharing problems with different cache line size and different starting address of an object 
%without the need of another execution. 

\Predator{} has the following contributions:
\begin{itemize}
\item
\textbf{General Detection Method:}\Predator{} provides a novel false sharing detection method by
combining compiler instrumentation with runtime system.
%, which can avoid the shortcomings of existing tools. 
Since it neither relies on the support of specific hardware and OS ,
nor binds to specific threading library, 
this method is suitable for the entire software stack, 
i.e., hypervisors, operating systems, libraries and applications.
But the remainder of this paper only talks about detecting false sharing problems in multi-threaded 
programs, so we use ``threads'' to replace ``computing unit'' from now on.
%Since compiler can be utilized to do selective instrumentation, 
%\Predator{} can be utilized to detect all kinds of false sharing problem with ideal overhead. 

% effect: can detect all kinds of false sharing problems.
\item
\textbf{Practicable Detection Tool:} \Predator{} can actually detect all kinds of false sharing 
problems accurately and precisely 
with reasonable overhead, around $7\times$ performance overhead and $22\%$ memory overhead. 
It reveals some unknown false sharing problems in those benchmark suites evaluated by 
previous approaches.
It is also the first false sharing tool to uncover false sharing problems of real applications, e.g.,
\texttt{mysql} server application and \texttt{boost} library. Fixing these problems 
improves performance about $6\times$ and $40\%$ correspondingly.
% combine compiler instrumentation with runtime system, so that it can 
%detect all kinds of false sharing problem including write-write false sharing. 
%avoid the shortcomings of runtime-only system, where Sheriff can not detect the read-writee false sharings. 
%Also, because of the limit of their implementation, Sheriff can not support the program using the ad hoc synchronization
%or using the stack variables to communicate among different threads.
%Also, it looks like that we can provide a evenly performance overhead.
%Also, sheriff should only work on specific thread library, currently, it can only work on pthreads library. 
%We are trying to extending the same idea to different thread library. Now we can also run DeFault to detect all 
%false sharings using other threads libraries.

% prediction
\item
\textbf{Accurate Prediction Approach:}\Predator{} is the first approach to accurately predict potential false sharing that does
not manifest in an execution but may appear and greatly affect the performance of programs 
in a slightly different environment. 
This avoids the predicament of detection tools: problems may occur in a real
environment rather than test environment due to environmental changes. 
%Existing approaches is based on specific hardware,
%runtime environment(using specific libraries and compilers) and specific cache line size, which is OK to detect those 
%existing false sharings. But they fail to capture those variables or objects which can greately slow down performance 

%In order to save memory usage, we propose a threshold invoked detection based on the predefined number of writes on a cache line, which
%can be used to track the .

\end{itemize}

\subsection*{Outline}

The remainder of this paper is organized as follows. 
Section~\ref{sec:detection} describes \Predator{}'s detection mechanisms and
algorithms in detail.
Section~\ref{sec:prediction} discusses how to predict potential false sharing accurately 
without occurrence. 
Section~\ref{sec:evaluation} presents experimental results, including using \Predator{} to 
reveal unknown false sharing problems in several benchmarks and real applications. 
Section~\ref{sec:discussion} discuesses prediction limitations and presents our future work.
Finally, 
Section~\ref{sec:relatedwork} describes key related work and Section~\ref{sec:conclusion} concludes.


%There are two types of false sharings:
%A. Different threads are accessed different locations according to the definition of flase sahrings. 
%B. Locations with a large amount of reads is placed in the cache line with a large amount of writes.
%For the second type, existing tools may tend to miss that.  
